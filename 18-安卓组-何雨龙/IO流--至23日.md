[toc]
# IO流
- ## 1.IO流概述
1.1 IO流用来处理设备之间的数据传输 

1.2 Java对数据的操作是通过流的方式

1.3 Java用于操作流的对象都在IO包中

1.4 流按操作数据分为两种:字节流与字符流。

流按流向分为：输入流，输出流

1.5 **IO流常用基类：**  
字节流的抽象基类：  
InputStream，OutPutStream  
字符流的抽象基类：  
Reader，Writer

**注：由这四个类派生的子类名称都是都是以其父类名作为子类名的后缀。**  
如：  
InputStream的子类FileInputStream  
Reader的子类FileReader

- ## 2.字符流  
### 2.1 FileWriter
    import java.io.*;
    public class FileWriterDemo {
    	public static void main(String[]args)throws Exception {
    		FileWriter fw=new FileWriter("barry.txt");
    		//创建一个FileWriter对象，该对象一初始化就要明确被操作的文件
    		//而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。
    		fw.write("barryallenwho\r\n");//将字符串写入到流当中
    		fw.flush();//刷新流对象中的缓冲中的数据，将数据刷的目的地中
    		fw.write("good");
    		fw.close();
    		//fw.write("cdccd");此时流已关闭，不能再写入。
    	}
    	public static void sop(Object obj) {
    		System.out.println(obj);
    	}
    }
### 2.2 IO异常处理&文件的续写

    import java.io.*;
    public class ListTest {
    	public static void main(String[]args) {
    		FileWriter fw=null;
    		/*凡是和设备数据发生的关系的操作：创建流对象，读，写等都会发生IO异常*/
    		try {
    			fw=new FileWriter("Oliver.txt");
    			//fw.new FileWriter("Oliver.txt",true);
    			//次方法可以实现文件续写，而不会覆盖原文件
    			fw.write("MynameisOliver");
    		}
    		catch(IOException e){
    			sop(e.toString());
    		}
    		finally{
    				try {
    					if(fw!=null)//防止对象为空异常
    					fw.close();
    				}
    				catch(IOException e){
    					sop(e.toString());
    				}
    			}
    		}
    }
### 2.3文本文件读取方式
#### 方式一：read( )
    import java.io.*;
    public class Test03 {
        public static void main(String[] args) throws IOException {
        	//创建读取字符数据的流对象。
        	FileReader fr=new FileReader("demo.txt"); ///如果找不到文件，则抛出异常
        	
        	//用Reader中的read方法读取字符
            int ch =fr.read();
            System.out.println(ch);   //读取一个字符,如果读取到结尾符，则返回-1
        }
    
    }
    
#### 方式二：read(char [])
一次性读多个字符：创建一个容器char []buf=new char[1024]，用于缓冲读到的字符。


        import java.io.*;
    public class ListTest {
    	public static void main(String[]args) throws IOException{
    		FileReader fr=new FileReader("Oliver.txt");
    		char []buf=new char[1024];
    		int num=0;
    		while((num=fr.read(buf))!=-1) {
    			sop(new String(buf,0,num));
    		}
    		
    	}
    	public static void sop(Object obj) {
    		System.out.println(obj);
    	}
    }
#### 拷贝文本文件练习
[拷贝文本文件图解](http://note.youdao.com/noteshare?id=bf0dc93aa7c89019d34f1ee81f7b7dcc&sub=33F70F7BED32449EB3ED644C27B41312)

    import java.io.*;
    public class ListTest {
    	public static void main(String[]args){
    		//创建一个读取已有文本文件的读取流对象
    		FileReader fr=null;
    		//创建一个写入目的存储文件的写入流对象
    		FileWriter fw=null;
    		try {
    			fr=new FileReader("Test5.java");
    			fw=new FileWriter("Test5_Copy.txt");
    			int len=0;
    			char[]buf=new char[1024];
    			while((len=fr.read(buf))!=-1) {
    				fw.write(buf,0,len);
    			}
    		}
    		catch(IOException e){
    			throw new RuntimeException("读写失败！");
    		}
    		finally {
    			if(fr!=null)
    				try {
    					fr.close();
    				}
    			catch(IOException e) {
    			}
    			if(fw!=null)
    				try {
    					fw.close();
    				}
    			catch(IOException e) {
    			}
    		}
    	}
    }
### 2.4缓冲区
#### 2.4.1BufferedWriiter
缓冲区的出现是为了提高流的操作效率。  
所以在创建缓冲区，必须要先有流对象  
该缓冲区提供了一个跨平台的换行符方法：newLine

    import java.io.*;
    public class ListTest {
    	public static void main(String[]args)throws IOException{
    		FileWriter fw=new FileWriter("Oliver.txt");
    		BufferedWriter bfwt=new BufferedWriter(fw);
    		for(int i=1;i<4;i++) {
    			bfwt.write("abcd"+i);
    			bfwt.newLine();
    			bfwt.flush();
    		}
    		bfwt.close//内部操作是将流关闭
    		}
    	}
    	
#### 2.4.2BufferedReader 
该缓冲区提供了一个一次读一行的方法readLine,方便于对数据的获取，当返回null时，表示读到文件末尾。

    import java.io.*;
    public class ListTest {
    	public static void main(String[]args)throws IOException{
    		FileReader fr=new FileReader("Oliver.txt");
    		BufferedReader bfwt=new BufferedReader(fr);
    		String line=null;
    		while((line=bfwt.readLine())!=null){
    			System.out.println(line);
    		}
    		}
    	}
#### 2.4.3通过缓冲区复制文本文件

    import java.io.*;
    public class ListTest {
    	public static void main(String[]args){
    		BufferedReader r=null;
    		BufferedWriter w=null;
    		try {
    			r=new BufferedReader(new FileReader("Test5.java"));
    			w=new BufferedWriter(new FileWriter("Test5_Copy.txt"));
    			String line=null;
    			/*readLine方法只能返回回车符之前的数据内容，并不返回回车符*/
    			while((line=r.readLine())!=null) {
    				w.write(line);
    				w.newLine();
    				w.flush();
    			}
    		}
    		catch(IOException e) {
    			throw new RuntimeException("读写失败!");
    		}
    		finally {
    			if(r!=null)
    			try {
    				r.close();
    			}
    			catch(IOException e) {
    				throw new RuntimeException("读取流关闭失败!");
    			}
    			if(w!=null)
    				try {
    					w.close();
    				}
    				catch(IOException e) {
    					throw new RuntimeException("写入流关闭失败!");
    				}
    		}
    		}
    	}

#### 2.4.4自定义MybufferedReader(readLine方法)
[ReadLine原理图解](http://note.youdao.com/noteshare?id=213963720227f9d08b24d5d022eaabe9&sub=44BAE943A5B44A8CB9D43000C9F929EA)

#### 2.4.5装饰设计模式和继承的区别
    public class PersonDemo {
    
        public static void main(String[] args) {
            Person p = new Person();
            SuperPerson sp = new SuperPerson(p);
    
            sp.chifan();
        }
    
    }
    
    class Person {
        void chifan() {
            System.out.println("吃饭");
        }
    }
    
    //装饰设计模式： 这个类是为了增强Person的功能而出现的
    class SuperPerson {
        private Person p;
    
        NewPerson(Person p) {
            this.p = p;
        }
    
        void chifan() { // 对Person的chifan方法进行增强。
            System.out.println("开胃酒");
            p.chifan();
            System.out.println("甜点");
        }
    }
    
首先有一个继承体系MyReader（用于读取数据的类）  
**MyReader**  
|---MyTextReader  
&emsp;&emsp;&emsp;|---MyBufferTextReader  
|---MyMediaReader  
&emsp;&emsp;&emsp;|---MyBufferMediaReader  
|---MyDataReader    
&emsp;&emsp;&emsp;|---MyBufferDataReader    
继承：多一个流对象就多写一个增强类，导致继承体系越来越臃肿    
这时我们抽取处共同的增强功能：缓冲  

    MyBufferReader{
        MyBufferReader(MyTextReader text){}
        MyBufferReader(MyMediaReader media){}
        MyBufferReader(MyDataReader data){}
    }
        
有了这个修饰类：我们发现每多一个新的流对象，就要新增一个构造函数，使得这个修饰类拓展性很差 。  
找到其参数的共同类型（MyReader）。通过多态的形式，可以提高拓展性。

    MyBufferReader extends MyReader {
        private MyReader r;
        MyBufferReader(MyReader r){
            this.r=r;
        }
    }

**MyReader**  
|---MyTextReader  
|---MyMediaReader  
|---MyDataReader  
|---MyBufferReader

装饰类模式比继承灵活，避免了继承体系臃肿。而且降低了类于类之间的关系。  
装饰类因为增强已有对象，具有已有的功能，又提供了增强功能，所以装饰类和被装饰类通常是属于一个体系中。

## 3.字节流
### 3.1字节流操作文件  
    import java.io.*;
    
    public class Test03
    {
    	public static void main(String[]args) throws IOException
    	{
    	    write();
    		read();
    	}
    
    	public static void read() throws IOException {
    		
    		//1.创建一个读取流对象。和指定文件关联
    		FileInputStream fis=new FileInputStream("Oliver.txt");
    		byte []buf=new byte[fis.available()];
    		fis.read(buf);
    		System.out.println(new String(buf))
    		
    		
    		//防止内存溢出建议使用这种读取数据的方式
    		/*byte[] buf=new byte[1024];
    		
    		int len=0;
    		
    		while((len=fis.read(buf))!=-1)
    		{
    			System.out.println(new String(buf,0,len));
    		}
    		//一个一个读
    		int ch=0;
    		while((ch=fis.read())!=-1)
    		{
    			System.out.println((char)ch);
    		}*/
    	    }
    	public static void write() throws IOException {
		
		//1.创建字节输出流对象。用于操作文件。
		FileOutputStream fos=new FileOutputStream("Barry.txt");
		
		//2.写数据,直接写入到了目的地中
		fos.write("abcdefg".getBytes());
		
		fos.close();//不需要刷新，但要完成关闭资源的动作
		
	    }
    }
### 3.2字节流的缓冲区（MP3的拷贝练习）

    package ioProject;
    import java.io.*;
    
    public class InputOutputDemo  {
    	public static void main(String[]args)throws IOException {
    		BufferedInputStream i=new BufferedInputStream(new FileInputStream("music.mp3"));
    		BufferedOutputStream o=new BufferedOutputStream(new FileOutputStream("Mymusic.mp3"));
    		byte []buf=new byte[1024];
    		int len=0;
    		while((len=i.read(buf))!=-1) {
    			o.write(buf,0,len);
    		}
    		i.close();
    		o.close();
    	}
    }
### 3.3读取键盘录入

    package ioProject;
    import java.io.*;
    public class KeybordOutput {
    	public static void main(String[]args)throws IOException {
    		InputStream in =System.in;
    		StringBuilder sb=new StringBuilder();
    		while(true) {
    			int ch=in.read();
    			//read的方法是一个堵塞式方法
    			//没有读到数据就等再那  
    			if(ch=='\r')
    				continue;
    					if(ch=='\n')
    					{
    					String s=sb.toString();
    						if("over".equals(s))
    							break;
    					System.out.println(s.toUpperCase());
    					sb.delete(0, sb.length());
    					}
    					else
    				sb.append((char)ch);
    		}
    		 
    	}
    }
